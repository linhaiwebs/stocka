#!/usr/bin/env node

/**
 * Template Registry Generator
 *
 * This script automatically scans the templates directory and generates
 * a TypeScript registry file for dynamic template loading.
 *
 * Usage: node scripts/generate-template-registry.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT = path.resolve(__dirname, '..');
const TEMPLATES_DIR = path.join(PROJECT_ROOT, 'templates');
const OUTPUT_FILE = path.join(PROJECT_ROOT, 'src', 'components', 'template-registry.generated.ts');

const COLORS = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
};

function log(message, color = 'reset') {
  console.log(`${COLORS[color]}${message}${COLORS.reset}`);
}

function logError(message) {
  log(`[ERROR] ${message}`, 'red');
}

function logWarning(message) {
  log(`[WARNING] ${message}`, 'yellow');
}

function logInfo(message) {
  log(`[INFO] ${message}`, 'blue');
}

function logSuccess(message) {
  log(`[SUCCESS] ${message}`, 'green');
}

/**
 * Check if a directory is a valid template directory
 */
function isValidTemplateDir(dirPath) {
  const manifestPath = path.join(dirPath, 'manifest.json');
  const indexTsxPath = path.join(dirPath, 'index.tsx');
  const indexTsPath = path.join(dirPath, 'index.ts');

  return fs.existsSync(manifestPath) && (fs.existsSync(indexTsxPath) || fs.existsSync(indexTsPath));
}

/**
 * Read and parse manifest.json
 */
function readManifest(dirPath) {
  const manifestPath = path.join(dirPath, 'manifest.json');
  try {
    const content = fs.readFileSync(manifestPath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    throw new Error(`Failed to parse manifest.json: ${error.message}`);
  }
}

/**
 * Validate manifest data
 */
function validateManifest(manifest, dirName) {
  if (!manifest.slug) {
    throw new Error(`Missing required field "slug" in manifest`);
  }

  if (!manifest.name) {
    throw new Error(`Missing required field "name" in manifest`);
  }

  if (manifest.slug !== dirName) {
    logWarning(`Manifest slug "${manifest.slug}" doesn't match directory name "${dirName}"`);
  }

  return true;
}

/**
 * Scan templates directory and collect valid templates
 */
function scanTemplates() {
  logInfo('Scanning templates directory...');

  if (!fs.existsSync(TEMPLATES_DIR)) {
    throw new Error(`Templates directory not found: ${TEMPLATES_DIR}`);
  }

  const entries = fs.readdirSync(TEMPLATES_DIR, { withFileTypes: true });
  const templates = [];
  const slugs = new Set();

  for (const entry of entries) {
    if (!entry.isDirectory()) {
      continue;
    }

    const dirName = entry.name;
    const dirPath = path.join(TEMPLATES_DIR, dirName);

    // Skip non-template directories
    if (dirName.startsWith('.') || dirName === 'node_modules') {
      continue;
    }

    // Check if it's a valid template directory
    if (!isValidTemplateDir(dirPath)) {
      logWarning(`Skipping "${dirName}": missing manifest.json or index.tsx/ts`);
      continue;
    }

    try {
      const manifest = readManifest(dirPath);
      validateManifest(manifest, dirName);

      // Check for duplicate slugs
      if (slugs.has(manifest.slug)) {
        throw new Error(`Duplicate template slug found: "${manifest.slug}"`);
      }

      slugs.add(manifest.slug);
      templates.push({
        slug: manifest.slug,
        name: manifest.name,
        dirName: dirName,
      });

      logSuccess(`Found template: ${manifest.name} (${manifest.slug})`);
    } catch (error) {
      logError(`Error processing template "${dirName}": ${error.message}`);
      throw error;
    }
  }

  return templates;
}

/**
 * Generate TypeScript registry code
 */
function generateRegistryCode(templates) {
  const timestamp = new Date().toISOString();
  const templateNames = templates.map(t => t.slug).join(', ');

  const imports = templates
    .map(t => `  '${t.slug}': () => import('../../templates/${t.dirName}/index'),`)
    .join('\n');

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is automatically generated by scripts/generate-template-registry.js
// Generated at: ${timestamp}
// Templates found: ${templateNames}

import { ComponentType } from 'react';
import { TemplateProps } from '../../templates/types';

export const templateRegistry: Record<string, () => Promise<{ default: ComponentType<TemplateProps> }>> = {
${imports}
};

export const availableTemplates = [
${templates.map(t => `  '${t.slug}',`).join('\n')}
] as const;
`;
}

/**
 * Write generated code to file
 */
function writeRegistryFile(code) {
  const outputDir = path.dirname(OUTPUT_FILE);

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, code, 'utf-8');
  logSuccess(`Registry file written to: ${OUTPUT_FILE}`);
}

/**
 * Main execution
 */
function main() {
  try {
    log('\n==============================================', 'bright');
    log('  Template Registry Generator', 'bright');
    log('==============================================\n', 'bright');

    const templates = scanTemplates();

    if (templates.length === 0) {
      logWarning('No valid templates found!');
      logWarning('Creating empty registry...');
    } else {
      logInfo(`\nFound ${templates.length} template(s)`);
    }

    const code = generateRegistryCode(templates);
    writeRegistryFile(code);

    log('\n==============================================', 'bright');
    logSuccess('Template registry generated successfully!');
    log('==============================================\n', 'bright');

    process.exit(0);
  } catch (error) {
    log('\n==============================================', 'bright');
    logError('Failed to generate template registry');
    logError(error.message);
    log('==============================================\n', 'bright');
    process.exit(1);
  }
}

main();
